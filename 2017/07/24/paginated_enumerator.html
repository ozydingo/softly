<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Fun With Enumerators: enumerating over paginated content</title>
  <meta name="description" content="Summary">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2017/07/24/paginated_enumerator.html">
  <link rel="alternate" type="application/rss+xml" title="Speak Softly" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Speak Softly</a>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Fun With Enumerators: enumerating over paginated content</h1>
    <p class="post-meta"><time datetime="2017-07-24T00:00:00-04:00" itemprop="datePublished">Jul 24, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <hr />
<h2 id="summary">Summary</h2>

<p>Use this code to seamlessly enumerate over paged content (such as an api index route) using a simple <code class="highlighter-rouge">data.each</code> call. Pages are only fetched when requested.</p>

<hr />

<p>Skip to <a href="#tl-dr">tl;dr</a></p>

<h2 id="enumerators-and-enumerables">Enumerators and Enumerables</h2>

<p><code class="highlighter-rouge">Enumerator</code>s and the <code class="highlighter-rouge">Enumerable</code> module in Ruby are very richly featured and, in my opinion, among its most appealing design choices (although I do confess some love for Python’s iterators, as well). Using these features effectively often makes up a good deal of low hanging fruit in code refactoring code for performance and readbility (simultaneously!), and so is very worth some exploration! Let’s quickly start at the beginning.</p>

<p><code class="highlighter-rouge">Enumerable</code> is simply a module specifying a collection of methods such as <code class="highlighter-rouge">each</code>, <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">select</code>, and so on. Classes that include <code class="highlighter-rouge">Enumerable</code> are what you probably think of when you think of enumerating, such as <code class="highlighter-rouge">Array</code> and <code class="highlighter-rouge">Hash</code>.</p>

<p><code class="highlighter-rouge">Enumerator</code>s are object you are actually dealing with every time you call these methods. Ruby abstracts away its details very neatly in the <code class="highlighter-rouge">Enumerable</code> methods signatures such that you’re rarely dealing with them directly. But <code class="highlighter-rouge">Enumerator</code> are what allow you to chain these methods such as in <code class="highlighter-rouge">data.map.with_index{|obj, ii| "#{ii}: #{obj}</code>, and how we can get the awesomeness of <a href="http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy">lazy enumerators</a>.</p>

<p>We’re going to get a little practice leveraging <code class="highlighter-rouge">Enumerator</code>s by implementing an <code class="highlighter-rouge">Enumerable</code> class that abstracts away the details of fetching bufferred or paginated content. The use case that inspired building this class, for example, was a routine to loop through and selectively pull media content from various hosts’ API calls that listed albums. For some of the APIs, but not others, these albums were returned in pages. We wanted to build a common structure where the logic for looping over the content itself did not have to be made aware of the pagination; it could just <code class="highlighter-rouge">data.each</code> and the details of how to get the <code class="highlighter-rouge">next</code> item was up to the object passed to it.</p>

<h2 id="paginatedenumerator">PaginatedEnumerator</h2>

<p>We’re going to build a class called <code class="highlighter-rouge">PaginatedEnumerator</code>. Despite <a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/">some advice to the contrary</a>, we’re going to <code class="highlighter-rouge">include Enumerable</code> here, because this is intended to be a very general use class and I want the users of this class to be able to call <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">reduce</code>, <code class="highlighter-rouge">find</code>, and, yes, even <code class="highlighter-rouge">minimax</code> if they so choose.</p>

<p>The user will then be able to use it like so:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="no">PaginatedEnumerator</span><span class="p">.</span><span class="nf">new</span><span class="p">{.</span><span class="nf">.</span><span class="o">.</span><span class="p">}</span>
<span class="n">data</span><span class="p">.</span><span class="nf">each</span><span class="p">{</span><span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="n">do_something_with</span><span class="p">(</span><span class="n">item</span><span class="p">)}</span>
</code></pre>
</div>

<p>And that’s it! The key is the block provided to <code class="highlighter-rouge">new</code> – this needs to tell our <code class="highlighter-rouge">PaginatedEnumerator</code> it how to fetch the next page. With that, any calls to <code class="highlighter-rouge">each</code>, or <code class="highlighter-rouge">minimax</code>, or any other <code class="highlighter-rouge">Enumerable</code> method can ignore the details of pagination. So let’s flesh out what that block should look like.</p>

<h2 id="fetching-the-page">Fetching the page</h2>

<p>A good first spec for how the user can tell us how to fetch a page is with a block that takes a page number as an argument. So this might look like</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="no">PaginatedEnumerator</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span><span class="o">|</span><span class="n">page</span><span class="o">|</span> <span class="n">fetch_page</span><span class="p">(</span><span class="n">page</span><span class="p">)}</span>
</code></pre>
</div>

<p>where <code class="highlighter-rouge">fetch_page(page)</code> makes a web request with the appropriate parameters. A key detail here is that <code class="highlighter-rouge">fetch_page</code> will only be called only when needed, so a loop won’t immediatly try to make 100 API calls, or however many are neede to reach the end of the data.</p>

<p>Speaking of the end of the data, let’s add one more detail to our spec: if there is no data left, the block should return an empty <code class="highlighter-rouge">Array</code>. That way we know when we’re done. With Ruby’s <code class="highlighter-rouge">Enumerator</code>s, the pattern we will follow is to <code class="highlighter-rouge">raise StopIteration</code> when we observe this condition.</p>

<h2 id="sketching-out-the-class">Sketching out the class</h2>

<p>In pseudocode, the class should look roughly like</p>
<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PaginatedEnumerator</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pager</span><span class="p">)</span>
    <span class="c1"># store the block, which specifies how to get the next page</span>
    <span class="vi">@pager</span> <span class="o">=</span> <span class="n">pager</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="vi">@buffer</span> <span class="o">+=</span> <span class="n">fetch_page</span><span class="p">(</span><span class="n">current_page</span><span class="p">)</span> <span class="k">if</span> <span class="n">need_page?</span>
      <span class="k">raise</span> <span class="no">StopIteration</span> <span class="k">if</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="k">yield</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">shift</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Actually, this isn’t too far from the final code. This is why I love Ruby.</p>

<p>In the <code class="highlighter-rouge">initialize</code> method, we store the block (called <code class="highlighter-rouge">&amp;pager</code>), which should look like what we said above: it takes a page number as an argument, and returns the data at that page. We also initialize a <code class="highlighter-rouge">@buffer</code>, which stores the values we’ve already fetched from the API.</p>

<p>Ok, but how do we actually implement <code class="highlighter-rouge">fetch_page</code>? This is actually quite easy with Ruby <code class="highlighter-rouge">Block</code>s and <code class="highlighter-rouge">Proc</code>s:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetch_page</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
  <span class="vi">@pager</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>So let’s keep an index, <code class="highlighter-rouge">@page</code>, that we’ll initialize to <code class="highlighter-rouge">0</code> by default, but allow the user to override.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="ss">page: </span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pager</span><span class="p">)</span>
    <span class="vi">@pager</span> <span class="o">=</span> <span class="n">pager</span>
    <span class="vi">@page</span> <span class="o">=</span> <span class="n">page</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>
</code></pre>
</div>

<p>We’ve define <code class="highlighter-rouge">each</code>, as <code class="highlighter-rouge">Enumerable</code>s are wont to do. Given the <code class="highlighter-rouge">Enumerable</code> module, we now get, for free, all of our favorite <code class="highlighter-rouge">Enumerble</code> methods! Well, except for one detail: we need to return an <code class="highlighter-rouge">Enumerator</code> if there is no block given to <code class="highlighter-rouge">each</code>. This is as simple as</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">each</span>
  <span class="k">return</span> <span class="n">enum_for</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">if</span> <span class="o">!</span><span class="nb">block_given?</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
</div>

<p>Returning the <code class="highlighter-rouge">Enumerator</code> provided by <code class="highlighter-rouge">enum_for</code> allows us to call this method without a block and chain enumerators, pass them around without evaluation, or create lazy enumerators.</p>

<h2 id="do-the-loop">Do the loop</h2>

<p>The <code class="highlighter-rouge">loop</code> and <code class="highlighter-rouge">yield</code> pattern is the heart of enumeration in Ruby. Given a block, such as that in <code class="highlighter-rouge">data.each{|x| puts x}</code>, the <code class="highlighter-rouge">yeild</code> is what executes the code in that block: <code class="highlighter-rouge">yield(value)</code> calls <code class="highlighter-rouge">puts x</code> with <code class="highlighter-rouge">value</code> in the place of <code class="highlighter-rouge">x</code>.</p>

<p>But we need a stop condition. As mentioned above, our requirement is that your block given to <code class="highlighter-rouge">PaginatedEnumerator.new</code> returns [] when there are no values left. It’s nice to formalize this requirement to isolate our class from the innumerable (see what I did there?) ways the inner code may behave when its out of data (<code class="highlighter-rouge">nil</code>, <code class="highlighter-rouge">[]</code>, <code class="highlighter-rouge">false</code>, <code class="highlighter-rouge">raise</code>…). Thus we leave that knowledge up to the caller. We simply respond to this condition of no more data (<code class="highlighter-rouge">[]</code>) by raising <code class="highlighter-rouge">StopIteration</code>, which is an <code class="highlighter-rouge">Enumerator</code>’s signal to stop looping.</p>

<p>So that builds out out <code class="highlighter-rouge">each</code> method like so:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">each</span>
  <span class="k">return</span> <span class="n">enum_for</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">if</span> <span class="o">!</span><span class="nb">block_given?</span>

  <span class="kp">loop</span> <span class="k">do</span>
    <span class="c1"># Fetch a page if we're out of data</span>
    <span class="vi">@buffer</span> <span class="o">+=</span> <span class="n">fetch_page</span> <span class="k">if</span> <span class="n">page_needed?</span>
    <span class="k">raise</span> <span class="no">StopIteration</span><span class="p">,</span> <span class="s2">"No more data"</span> <span class="k">if</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">yield</span> <span class="vi">@stored_values</span><span class="p">.</span><span class="nf">shift</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Putting this all together, we have a nice, concise, and very useful class!:</p>

<p><a href="#" name="tl-dr"></a></p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PaginatedEnumerator</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="ss">page: </span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"Block required to define how to fetch new records"</span> <span class="k">if</span> <span class="n">blk</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"Block needs to take exactly one argument (current page)"</span> <span class="k">if</span> <span class="n">blk</span><span class="p">.</span><span class="nf">arity</span> <span class="o">!=</span> <span class="mi">1</span>

    <span class="vi">@pager</span> <span class="o">=</span> <span class="n">blk</span>
    <span class="vi">@page</span> <span class="o">=</span> <span class="n">page</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">return</span> <span class="n">enum_for</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">unless</span> <span class="nb">block_given?</span>

    <span class="kp">loop</span> <span class="k">do</span>
      <span class="k">if</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">empty?</span>
        <span class="vi">@buffer</span> <span class="o">+=</span> <span class="n">fetch_page</span><span class="p">(</span><span class="vi">@page</span><span class="p">)</span>
        <span class="k">raise</span> <span class="no">StopIteration</span> <span class="k">if</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">empty?</span>
        <span class="vi">@page</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="k">yield</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">shift</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">fetch_page</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
    <span class="vi">@pager</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h2 id="in-action">In action</h2>

<p>Let’s use it!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2.3.3 &gt; ee = PaginatedEnumerator.new do|page|
2.3.3 &gt;   puts "&gt;&gt;&gt; FETCHING page #{page}"
2.3.3 &gt;   if page &gt; 3
2.3.3 &gt;     puts "&gt;&gt;&gt; Out of data!"
2.3.3 &gt;     []
2.3.3 &gt;   else
2.3.3 &gt;     # Dummy content
2.3.3 &gt;     ('a'..'c').map{|char| "#{page}:#{char}"}
2.3.3 &gt;   end
2.3.3 &gt; end
# =&gt; #&lt;PaginatedEnumerator:0x007fa6b5a90f48 @pager=#&lt;Proc:0x007fa6b5a90ef8@(irb):30&gt;, @page=0, @buffer=[]&gt;
2.3.3 &gt; ee.each.with_index{|x, ii| puts "#{ii}: Next value: #{x}"}

### output
&gt;&gt;&gt; FETCHING page 0
0: Next value: 0:a
1: Next value: 0:b
2: Next value: 0:c
&gt;&gt;&gt; FETCHING page 1
3: Next value: 1:a
4: Next value: 1:b
5: Next value: 1:c
&gt;&gt;&gt; FETCHING page 2
6: Next value: 2:a
7: Next value: 2:b
8: Next value: 2:c
&gt;&gt;&gt; FETCHING page 3
9: Next value: 3:a
10: Next value: 3:b
11: Next value: 3:c
&gt;&gt;&gt; FETCHING page 4
&gt;&gt;&gt; Out of data!
</code></pre>
</div>

<p>Notice how “FETCHING page n” is not printed until that page is reached; we are able to interact with each page’s data before fetching the next page. We can also easily use this with Ruby’s lazy enumerators:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="o">.</span><span class="mi">3</span> <span class="o">&gt;</span> <span class="n">ee</span><span class="p">.</span><span class="nf">lazy</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="nf">last</span> <span class="o">==</span> <span class="s2">"c"</span><span class="p">}.</span><span class="nf">first</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">1</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"0:c"</span><span class="p">,</span> <span class="s2">"1:c"</span><span class="p">]</span>
</code></pre>
</div>

<p>But without <code class="highlighter-rouge">lazy</code>, we would have fetch the entire data set before filtering!!:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="o">.</span><span class="mi">3</span> <span class="o">&gt;</span> <span class="n">ee</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="nf">last</span> <span class="o">==</span> <span class="s2">"c"</span><span class="p">}.</span><span class="nf">first</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">FETCHING</span> <span class="n">page</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="no">Out</span> <span class="n">of</span> <span class="n">data!</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"0:c"</span><span class="p">,</span> <span class="s2">"1:c"</span><span class="p">]</span>
</code></pre>
</div>

<p>Because of the magic of <code class="highlighter-rouge">lazy</code>, only the pages needed to select the first 2 results that matched the select condition were ever called. Wonderful!</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Speak Softly</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Speak Softly
            
            </li>
            
            <li><a href="mailto:ozydingo@gmail.com">ozydingo@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ozydingo"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ozydingo</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/ozydingo"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">ozydingo</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A blog about coding awesome, powerful tools...respectfully
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
